**************** WARNING WARNING WARNING ******************
*            (as the L.I.S ROBOT often said)              *
*                                                         *
* Because the listing in the adaption guide is incomplete *
* I have had to fudge the addresses to match the parts of *
* the MF-68 NEWDISK that are included in the guide.       *
* On line number 706 there is an ORG $4BC statement which *
* you will have to remove if you don't want the code to   *
* overlay itself (which is not recommended)               *
*                                                         *
***********************************************************


* NEWDISK
*
* COPYRIGHT (C) 1980 BY
* TECHNICAL SYSTEMS CONSULTANTS, INC.
* PO BOX 2570, W. LAFAYETTE, IN 47906
*
* DISK FORMATTING PROGRAM FOR 6800 FLEX
* GENERAL VERSION DESIGNED FOR WD 1771/1791
* THE NEWDISK PROGRAM INITIALIZES A NEW DISKETTE AND
* THEN PROCEEDS TO VERIFY ALL SECTORS AND INITIALIZE
* TABLES.  THIS VERSION IS SETUP FOR AN 8 INCH DISK
* SYSTEM WITH HINTS AT CERTAIN POINTS FOR ALTERING
* FOR A SINGLE-DENSITY 5 INCH DISK SYSTEM.  THIS
* VERSION IS NOT INTENDED FOR 5 INCH DOUBLE-DENSITY.

**************************************************
* DISK SIZE PARAMETERS
* **** **** **********
* THE FOLLOWING CONSTANTS SETUP THE SIZE OF THE
* DISK TO BE FORMATTED.  THE VALUES SHOWN ARE FOR
* 8 INCH DISKS. FOR 5 INCH DISKS, USE APPROPRIATE
* VALUES. (IE. 35 TRACKS AND 10 SECTORS PER SIDE)
**************************************************

MAXTRK EQU 35 NUMBER OF TRACKS
* SINGLE DENSITY:
SMAXS0 EQU 10 SD MAX SIDE 0 SECTORS
SMAXS1 EQU 10 SD MAX SIDE 1 SECTORS
* DOUBLE DENSITY:
DMAXS0 EQU 10 DD MAX SIDE 0 SECTORS
DMAXS1 EQU 10 DD MAX SIDE 1 SECTORS

**************************************************
* MORE DISK SIZE DEPENDENT PARAMETERS
* **** **** **** ********* **********
* THE FOLLOWING VALUES ARE ALSO DEPENDENT ON THE
* SIZE OF DISK BEING FORMATTED.  EACH VALUE SHOWN
* IS FOR 8 INCH WITH PROPER 5 INCH VALUES IN
* PARENTHESES.
**************************************************

* SIZE OF SINGLE DENSITY WORK BUFFER FOR ONE TRACK
TKSZ EQU 3050 (USE 3050 FOR 5 INCH)
* TRACK START VALUE
TST EQU 0 (USE 0 FOR 5 INCH)
* SECTOR START VALUE
SST EQU 7 (USE 7 FOR 5 INCH)
* SECTOR GAP VALUE
GAP EQU 14 (USE 14 FOR 5 INCH)

**************************************************

* WORK SPACE WHERE ONE TRACK OF DATA IS SETUP

WORK EQU $0800 WORK SPACE
SWKEND EQU TKSZ+WORK SINGLE DENSITY
DWKEND EQU TKSZ*2+WORK DOUBLE DENSITY

* GENERAL EQUATES

FIRST EQU $0101 FIRST USER SECTOR
FCS EQU 30 FCB CURRENT SECTOR
FSB EQU 64 FCB SECTOR BUFFER
IRS EQU 16 INFO RECORD START
AVLP EQU FSB+IRS+13
DIRSEC EQU 5 FIRST DIR. SECTOR
RDSS EQU 9 READ SS FMS CODE
WTSS EQU 10 WRITE SS FMS CODE
DATE EQU $AC0E DOS DATE

* FLEX ROUTINES EQUATES

PSTRNG EQU $AD1E
PUTCHR EQU $AD18
OUTDEC EQU $AD39
GETHEX EQU $AD42
GETCHR EQU $AD15
PCRLF EQU $AD24
INBUF EQU $AD1B
GETFIL EQU $AD2D
INDEC EQU $AD48
ADDBX EQU $AD36
FMS EQU $B406
FMSCLS EQU $B403
OUT2HS EQU $AD3C
WARMS EQU $AD03

* DISK DRIVER ROUTINES

DWRITE EQU $BE83 WRITE A SINGLE SECTOR
REST EQU $BE89 RESTORE HEAD
DSEEK EQU $BE9B SEEK TO TRACK
DRVDEN EQU $BEA3 *CONTROLLER ROUTINE DEPENDANT*

* TEMPORARY STORAGE

 ORG $0020

TRACK RMB 1
SECTOR RMB 1
BADCNT RMB 1 BAD SECTOR COUNT
DRN RMB 1
SIDE RMB 1
DBSDF RMB 1
DENSE RMB 1
DNSITY RMB 1
TEMP1 RMB 2
TEMP2 RMB 2
SECCNT RMB 2 SECTOR COUNTER
FSTAVL RMB 2 FIRST AVAILABLE
LSTAVL RMB 2 LAST AVAILABLE
MAXS0 RMB 1  MAX SIDE 0 SECTOR
MAXS1 RMB 1 MAX SIDE 1 SECTOR
MAX RMB 1 MAX SECTOR
FKFCB RMB 4
VOLNAM RMB 11
VOLNUM RMB 2
BUFEND RMB 2 END OF WORK SPACE

 ORG $0100

********************************************
* MAIN PROGRAM STARTS HERE
********************************************

NEWDISK BRA FORM1

VN FCB 2 VERSION NUMBER

OUTIN JSR PSTRNG OUTPUT STRING
OUTIN2 JSR GETCHR GET RESPONSE
 ANDA #$5F MAKE IT UPPER CASE
 CMPA #'Y SEE IF "YES"
 RTS

LEXIT JMP EXIT

FORM1 LDAA #SMAXS0 INITIALIZE SECTOR MAX
 STAA MAXS0
 STAA MAX
 LDAA #SMAXS1
 STAA MAXS1
 JSR GETHEX GET DRIVE NUMBER
 BCS LEXIT
 STX TEMP1
 LDAA TEMP1+1
 CMPA #3 ENSURE 0 TO 3
 BHI LEXIT
 LDX #WORK
 STAA 3,X
 STAA DRN
 LDX #SURES ASK IF HE'S SURE
 BSR OUTIN PRINT & GET RESPONSE
 BNE LEXIT EXIT IF "NO"
 LDX #SCRDS CHECK SCRATCH DRIVE NO.
 JSR PSTRNG OUTPUT IT
 LDX #WORK+2
 CLR 0,X
 CLRB
 JSR OUTDEC
 LDAA #'? PRINT QUESTION MARK
 JSR PUTCHR
 LDAA #$20
 JSR PUTCHR
 BSR OUTIN2 GET RESPONSE
 BNE LEXIT EXIT IF "NO"
 CLR DBSDF CLEAR FLAG
*** PLACE A "BRA FORM25" HERE IF HARDWARE IS
*** ONLY SINGLE SIDED.

 BRA FORM25

 LDX #DBST ASK IF DOUBLE SIDED
 BSR OUTIN PRINT & GET RESPONSE
 BNE FORM25 SKIP IF "NO"
 INC DBSDF SET FLAG
 LDAA #SMAXS1 SET MAX SECTOR
 STAA MAX
FORM25 CLR DENSE INITIALIZE SINGLE DENSITY
 CLR DNSITY
*** PLACE A "BRA FORM26" HERE IF HARDWARE IS
*** ONLY SINGLE DENSITY.

 BRA FORM26 ****ONLY SINGLE DENSITY****

 LDX #DDSTR ASK IF DOUBLE DENSITY
 BSR OUTIN PRINT & GET RESPONSE
 BNE FORM26 SKIP IF "NO"
 INC DENSE SET FLAG IF SO
FORM26 LDX #NMSTR ASK FOR VOLUME NAME
 JSR PSTRNG PRINT IT
 JSR INBUF GET LINE
 LDX #FKFCB POINT TO FAKE
 JSR GETFIL
FORM27 LDX #NUMSTR OUTPUT STRING
 JSR PSTRNG
 JSR INBUF GET LINE
 JSR INDEC GET NUMBER
 BCS FORM27 ERROR?
 STX VOLNUM SAVE NUMBER
 JSR PCRLF PRINT CR & LF
 LDX #WORK
 JSR REST RESTORE HEAD
 BEQ FORMAT SKIP IF NO ERROR
 LDX #WPST
 BITB #$40 WRITE PROTECT ERROR?
 BNE EXIT2 SKIP IF SO

* EXIT ROUTINES

EXIT LDX #ABORTS REPORT ABORTING
EXIT2 JSR PSTRNG OUTPUT STRING
EXIT3 JSR FMSCLS
 CLI
 JMP WARMS RETURN TO FLEX

**************************************************************
*
* ACTUAL FORMAT ROUTINE
*
* THIS CODE PERFORMS THE ACTUAL DISK FORMATTING BY PUTTING
* ON ALL GAPS, HEADER INFORMATION, DATA AREAS, SECTOR LINKING,
* ETC.  THIS SECTION DOES NOT WORRY ABOUT SETTING UP THE
* SYSTEM INFORMATION RECORD, BOOT SECTOR, OR DIRECTORY.
* IT ALSO DOES NOT NEED BE CONCERNED WITH TESTING THE DISK FOR
* ERRORS AND THE REMOVAL OF DEFECTIVE SECTORS ASSOCIATED WITH
* SUCH TESTING.  THESE OPERATIONS ARE CARRIED OUT BY THE
* REMAINDER OF THE CODE IN "NEWDISK".
* IF USING A WD1771 OR WD1791 CONTROLLER CHIP, THIS CODE SHOULD
* NOT NEED CHANGING (SO LONG AS THE WRITE TRACK ROUTINE AS
* FOUND LATER IS PROVIDED).  IF USING A DIFFERENT TYPE OF
* CONTROLLER, THIS CODE MUST BE REPLACED AND THE WRITE TRACK
* ROUTINE (FOUND LATER) MAY BE REMOVED AS IT WILL HAVE TO BE
* A PART OF THE CODE THAT REPLACES THIS FORMATTING CODE.
* WHEN THIS ROUTINE IS COMPLETED, IT SHOULD JUMP TO 'SETUP'.
*
**************************************************************


* MAIN FORMATTING LOOP


FORMAT SEI
 CLR TRACK
FORM3 CLR SIDE SET SIDE 0
 CLR SECTOR
 BSR TRKHD SETUP TRACK HEADER
FORM32 LDX #WORK+SST POINT TO SECTOR START
 LDAB DNSITY DOUBLE DENSITY?
 BEQ FORM4 SKIP IF NOT
 LDX #SST*2+WORK DD SECTOR START
FORM4 JSR DOSEC PROCESS RAM WITH INFO
 INC SECTOR ADVANCE TO NEXT
 LDAA SECTOR CHECK VALUE
 LDAB SIDE CHECK SIDE
 BNE FORM45
 CMPA MAXS0
 BRA FORM46
FORM45 CMPA MAXS1
FORM46 BNE FORM4 REPEAT?
FORM47 LDAA TRACK GET TRACK NUMBER
 LDAB SIDE FAKE SECTOR FOR PROPER SIDE
 JSR DSEEK SEEK TRACK AND SIDE
 JSR WRTTRK WRITE TRACK
FORM5 LDAB DBSDF ONE SIDE?
 BEQ FORM6
 LDAB SIDE
 BNE FORM6
 COM SIDE SET SIDE 1
 BRA FORM32
FORM6 INC TRACK BUMP TRACK
 JSR SWITCH SWITCH TO DD IF NCSSRY
FORM7 LDAA TRACK CHECK VALUE
 CMPA #MAXTRK DONE LAST TRACK?
 BNE FORM3 LOOP IF NOT
 JMP SETUP DONE...GO FINISH UP


* SETUP TRACK HEADER INFORMATION

TRKHD LDX #WORK POINT TO BUFFER
 LDAB DNSITY DOUBLE DENSITY?
 BNE TRHDD SKIP IF SO
 LDAB #$FF
TRHDS1 STAB 0,X INITIALIZE TO $FF
 INX
 CPX #SWKEND
 BNE TRHDS1
 LDX #WORK+TST
 CLRA SET IN ZEROS
 LDAB #6
 BRA TRHDD2
TRHDD LDAB #$4E
TRHDD1 STAB 0,X INITIALIZE TO $4E
 INX
 CPX #DWKEND
 BNE TRHDD1
 LDX #TST*2+WORK
 RTS
TRHDD2 BSR SET
 LDAA #$FC SET INDEX MARK
 STAA 0,X
 RTS

* SET (B) BYTES OF MEMORY TO (A) STARTING AT (X)

SET STAA 0,X
 INX
 DECB
 BNE SET
 RTS

* PROCESS SECTOR IN RAM

DOSEC CLRA
 LDAB #6 CLEAR BYTES
 TST DNSITY DOUBLE DENSITY?
 BEQ DOSEC2 SKIP IF NOT
DOSEC1 LDAB #8 CLEAR 8 BYTES
 BSR SET
 LDAA #$F5 SET IN 3 $F5'S
 LDAB #3
DOSEC2 BSR SET
 LDAA #$FE ID ADDRESS MARK
 STAA 0,X
 INX
 LDAA TRACK GET TRACK NO.
 STAA 0,X
 INX
 LDAB DNSITY DOUBLE DENSITY?
 BEQ DOSEC3 SKIP IF NOT
 LDAB SIDE GET SIDE INDICATOR
 ANDB #$01 MAKE IT 0 OR 1
DOSEC3 STAB 0,X
 INX
 STX TEMP1 SAVE X REGISTER
 LDX #SSCMAP POINT TO CORRECT MAP
 LDAB DNSITY
 BEQ DOSEC4
 LDX #DSCMAP
DOSEC4 LDAB SECTOR GET SECTOR NO.
 BEQ DOSC55
DOSEC5 INX GET ACTUAL SECTOR NUMBER
 DECB
 BNE DOSEC5
DOSC55 LDAB 0,X
 LDX TEMP1 RESTORE X REGISTER
 STAB 0,X
 INX
 CMPB MAX END OF TRACK?
DOSEC6 BNE DOSEC7 SKIP IF NOT
 INCA BUMP TRACK NO.
 CLRB RESET SECTOR NO.
 CMPA #MAXTRK END OF DISK?
 BNE DOSEC7 SKIP IF NOT
 CLRA SET ZERO FORWARK LINK
 LDAB #-1
DOSEC7 INCB BUMP SECTOR NO.
 PSHA SAVE FORWARD LINK
 PSHB
 LDAA #1 SECTOR LENGTH = 256
 STAA 0,X
 INX
 LDAA #$F7 SET CRC CODE
 STAA 0,X
 INX
 LDAB DNSITY DOUBLE DENSITY?
 BNE DOSEC8 SKIP IF SO
 LDAB #11 LEAVE $FF'S
 JSR ADDBX
 CLRA PUT IN 6 ZEROS
 LDAB #6
 BRA DOSEC9
DOSEC8 LDAB #22 LEAVE $4E'S
 JSR ADDBX
 CLRA PUT IN 12 ZEROS
 LDAB #12
 BSR SET
 LDAA #$F5 PUT IN 3 $F5'S
 LDAB #3
DOSEC9 JSR SET
 LDAA #$FB DATA ADDRESS MARK
 STAA 0,X
 INX
 PULB RESTORE FORWARD LINK
 PULA
 STAA 0,X PUT IN SECTOR BUFFER
 STAB 1,X
 INX
 INX
 CLRA CLEAR SECTOR BUFFER
 LDAB #254
 JSR SET
 LDAA #$F7 SET CRC CODE
 STAA 0,X
 INX
 LDAB #GAP LEAVE GAP
 JSR ADDBX
 LDAB DNSITY DOUBLE DENSITY?
 BEQ DOSECA SKIP IF NOT
 LDAB #8 22 BYTES FOR DD
 JSR ADDBX
DOSECA RTS

**************************************************************
*
* DISK TESTING AND TABLE SETUP
*
* THE FOLLOWING CODE TESTS EVERY SECTOR AND REMOVES ANY
* DEFECTIVE SECTORS FROM THE FREE CHAIN.  NEXT THE SYSTEM
* INFORMATION RECORD IS SETUP, THE DIRECTORY IS INITIALIZED,
* AND THE BOOT IS SAVED ON TRACK ZERO.  ALL THIS CODE SHOULD
* WORK AS IS FOR ANY FLOPPY DISK SYSTEM.  ONE CHANGE THAT
* MIGHT BE REQUIRED WOULD BE IN THE SAVING OF THE BOOTSTRAP
* LOADER.  SPECIAL BOOT LOADERS MIGHT REQUIRE CHANGES IN THE
* WAY THE BOOT SAVE IS PERFORMED.  FOR EXAMPLE, IT MAY BE
* NECESSARY TO SAVE TWO SECTORS IF THE BOOT LOADER DOES NOT
* FIT IN ONE.  ALSO IT MAY BE NECESSARY, BY SOME MEANS, TO
* INFORM THE BOOT LOADER WHETHER THE DISK IS SINGLE OR
* DOUBLE DENSITY SO THAT IT MAY SELECT THE PROPER DENSITY
* FOR LOADING FLEX.
*
**************************************************************


* READ ALL SECTORS FOR ERRORS

SETUP LDAA DENSE CHECK DENSITY
 BEQ SETUPP BRANCH IF SINGLE
 LDAA #$FF DENSITY BYTE FOR DISK DRIVERS
 LDX #DRVDEN DRIVE DENSITY STORE
 LDAB DRN GET DRIVE NUMBER
 BEQ SETP2
SETP1 INX MOVE X TO CORRECT BYTE
 DECB
 BNE SETP1
SETP2 STAA 0,X CHANGE DRIVE'S DENSITY
SETUPP LDAA MAX GET MAX SECTORS
 LDAB #MAXTRK-1 GET NUMBER OF USER TRACKS
 STAB LSTAVL SET LAST AVAIL.
 STAA LSTAVL+1
 LDX #0
SETUP0 LDAB #MAXTRK-1 FIND TOTAL SECTORS
 JSR ADDBX
 DECA
 BNE SETUP0
 STX SECCNT SAVE TOTAL SECTOR COUNT
 LDX #FIRST SET FIRST AVAIL
 STX FSTAVL
 LDAA DRN
 STAA WORK+3
 CLRA  CLEAR COUNTER
 STAA BADCNT
 STAA TRACK SET TRACK
 STAA DNSITY SNGL DNST FOR TRK 0
 INCA
 STAA SECTOR SET SECTOR
 LDAA #SMAXS0 RESET MAXIMUM
 STAA MAXS0 SECTOR COUNTS
 LDAA #SMAXS1
 STAA MAXS1
 LDAB DBSDF DOUBLE SIDED?
 BNE SETUP1 SKIP IF SO
 LDAA #SMAXS0
SETUP1 STAA MAX SET MAXIMUM SECTORS
SETUP2 BSR CHKSEC GO CHECK SECTOR
 BNE REMSEC ERROR?
 CLR BADCNT CLEAR COUNTER
SETUP4 LDAA TRACK GET TRACK & SECTOR
 LDAB SECTOR
 BSR FIXSEC GET TO NEXT ADR
 BEQ SETUP5 SKIP IF FINISHED
 STAA TRACK SET TRACK & SECTOR
 STAB SECTOR
 BRA SETUP2 REPEAT
SETUP5 JMP DOTRK

* CHECK IF SECTOR GOOD

CHKSEC LDX #WORK POINT TO FCB
 LDAA TRACK GET TRACK & SECTOR
 LDAB SECTOR
 STAA FCS,X SET CURRENT TRK & SCT
 STAB FCS+1,X
 JMP READSS GO DO READ

* SWITCH TO DOUBLE DENSITY IF NECESSARY

SWITCH LDAB DENSE DOUBLE DENSITY DISK?
 BEQ SWTCH2 SKIP IF NOT
 STAB DNSITY SET FLAG
 LDAB #DMAXS0 RESET SECTOR COUNTS
 STAB MAXS0
 LDAB #DMAXS1
 STAB MAXS1
 TST DBSDF DOUBLE SIDED?
 BNE SWTCH1 SKIP IF SO
 LDAB #DMAXS0
SWTCH1 STAB MAX SET MAX SECTOR
SWTCH2 RTS

* SET TRK & SEC TO NEXT

FIXSEC CMPB MAX END OF TRACK?
 BNE FIXSE4 SKIP IF NOT
 INCA  BUMP TRACK
 BSR SWITCH SWITCH TO DD IF NCSSRY
 CLRB RESET SECTOR NO.
FIXSE4 INCB BUMP SECTOR NO.
 CMPA #MAXTRK END OF DISK?
 RTS

* REMOVE BAD SECTOR FROM FREE SECTOR CHAIN

REMSEC INC BADCNT UPDATE COUNTER
 BEQ REMSE1 COUNT OVERFLOW?
 LDAA TRACK GET TRACK
 BNE REMSE2 TRACK 0?
 LDAB SECTOR GET SECTOR
 CMPB #DIRSEC PAST DIRECTORY?
 BHI REMSE2
REMSE1 LDX #FATERS  REPORT FATAL ERROR
 JMP EXIT2 REPORT IT
REMSE2 LDX #WORK POINT TO FCB
 LDAA FSTAVL GET 1ST TRACK & SECTOR
 LDAB FSTAVL+1
 CMPA TRACK CHECK TRACK
 BNE REMSE3
 CMPB SECTOR CHECK SECTOR
 BNE REMSE3
 BSR FIXSEC SET TO NEXT
 STAA FSTAVL SET NEW ADR
 STAB FSTAVL+1
 BRA REMSE8 GO DO NEXT
REMSE3 LDAA TRACK GET TRACK & SECTOR
 LDAB SECTOR
 SUBB BADCNT
 BEQ REMS35 UNDERFLOW?
 BPL REMSE4
REMS35 DECA  DEC TRACK
 LDAB MAX RESET SECTOR
REMSE4 STAA FCS,X SET CURRENT ADR
 STAB FCS+1,X
 BSR READSS GO DO READ
 BNE REMSE1 ERROR?
 LDAA FSB,X GET LINK ADR
 LDAB FSB+1,X
 BSR FIXSEC POINT TO NEXT
 BNE REMSE6 OVERFLOW?
 LDAA FCS,X GET CURRENT ADR
 LDAB FCS+1,X
 STAA LSTAVL SET NEW LAST AVAIL
 STAB LSTAVL+1
 CLRA  SET END LINK
 CLRB
REMSE6 STAA FSB,X SET NEW LINK
 STAB FSB+1,X
 BSR WRITSS GO DO WRITE
 BNE REMSE1 ERROR?
REMSE8 LDX SECCNT GET SEC COUNT
 DEX  DEC IT ONCE
 STX SECCNT SAVE NEW COUNT
 LDX #BADSS REPORT BAD SECTOR
 JSR PSTRNG OUTPUT IT
 LDX #TRACK POINT TO ADDRESS
 JSR OUT2HS OUTPUT IT
 LDAA #$20
 JSR PUTCHR
 INX BUMP TO NEXT
 JSR OUT2HS
 JMP SETUP4 CONTINUE

* READ A SECTOR

READSS LDX #WORK POINT TO FCB
 LDAA #RDSS SET UP COMMAND
 STAA 0,X
 JMP FMS GO DO IT

* WRITE A SECTOR

WRITSS LDX #WORK POINT TO FCB
 LDAA #WTSS SETUP COMMAND
 STAA 0,X
 JSR FMS GO DO IT
 BEQ READSS ERRORS?
 RTS  ERROR RETURN

* SETUP SYSTEM INFORMATION RECORD

DOTRK CLR DNSITY BACK TO SINGLE DENSITY
 LDX #WORK POINT TO SPACE
 CLR FCS,X SET TO DIS
 LDAA #3 SECTOR 3
 STAA FCS+1,X
 BSR READSS READ IN SIR SECTOR
 BNE DOTRK4 ERROR?
 LDX #WORK FIX POINTER
 CLR FSB,X CLEAR FORWARD LINK
 CLR FSB+1,X
 LDAA FSTAVL ADDR. OF 1ST FREE SCTR.
 LDAB FSTAVL+1
 STAA AVLP,X SET IN SIR
 STAB AVLP+1,X
 LDAA LSTAVL ADDR. OF LAST FREE SCTR.
 LDAB LSTAVL+1
 STAA AVLP+2,X PUT IN SIR
 STAB AVLP+3,X
 LDAA SECCNT GET TOTAL SECTOR COUNT
 LDAB SECCNT+1
 STAA AVLP+4,X PUT IN SIR
 STAB AVLP+5,X
 LDAA #MAXTRK-1 SET MAX TRACK NO.
 STAA AVLP+9,X PUT IN SIR
 LDAA MAXS0 SET MAX SECTORS/TRACK
 LDAB DBSDF DOUBLE SIDED?
 BEQ DOTRK2
 LDAA MAXS1 CHANGE FOR DOUBLE SIDED
DOTRK2 STAA AVLP+10,X SAVE IN SIR
 LDAA DATE SET DATE INTO SIR
 STAA AVLP+6,X
 LDAA DATE+1
 STAA AVLP+7,X
 LDAA DATE+2
 STAA AVLP+8,X
 LDAB #13
 LDX #VOLNAM POINT TO VOLUME NAME
 STX TEMP1
 LDX #WORK
 STX TEMP2
DOTR33 LDX TEMP1 COPY NAME TO SIR
 LDAA 0,X
 INX
 STX TEMP1
 LDX TEMP2
 STAA FSB+IRS,X
 INX
 STX TEMP2
 DECB DEC THE COUNT
 BNE DOTR33
 BSR WRITSS WRITE SIR BACK OUT
 BEQ DIRINT SKIP IF NO ERROR
DOTRK4 JMP REMSE1 GO REPORT ERROR

* INITIALIZE DIRECTORY

DIRINT LDX #WORK SET POINTER
 LDAA #SMAXS0 GET MAX FOR TRK 0
 TST DBSDF SINGLE SIDE?
 BEQ DIRIN1 SKIP IF SO
 LDAA #SMAXS1 SET MAX FOR DS
DIRIN1 STAA FCS+1,X SET UP
 JSR READSS READ IN SECTOR
 BNE DOTRK4 ERROR?
 LDX #WORK RESTORE POINTER
 CLR FSB,X CLEAR LINK
 CLR FSB+1,X
 JSR WRITSS WRITE BACK OUT
 BNE DOTRK4 ERRORS?

* SAVE BOOT ON TRACK 0 SECTOR 1

DOBOOT LDX #BOOT POINT TO LOADER CODE
 CLRA TRACK #0
 LDAB #1 SECTOR #1
 JSR DWRITE WRITE THE SECTOR
 BNE DOTRK4

* REPORT TOTAL SECTORS AND EXIT

 LDX #WORK SETUP AN FCB
 LDAA #16 OPEN SIR FUNCTION
 STAA 0,X
 JSR FMS OPEN THE SIR
 BNE DOTRK4
 LDAA #7 GET INFO RECORD FUNCTION
 STAA 0,X
 JSR FMS GET 1ST INFO RECORD
 BNE DOTRK4
 LDX #CMPLTE REPORT FORMATTING COMPLETE
 JSR PSTRNG
 LDX #SECST PRINT TOTAL SECTORS STRING
 JSR PSTRNG
 LDX #WORK+21 TOTAL IS IN INFO RECORD
 CLRB
 JSR OUTDEC PRINT NUMBER
 JMP EXIT3 ALL FINISHED!

********* WARNING GIANT KLUDGE TO MAKE ***********
********* ADDRESSES LINE UP WITH LISTING *********
********* DO NOT LEAVE THIS ORG HERE *************

 ORG $4BC
**************************************************
* SECTOR MAPS
* ****** ****
* THE MAPS SHOWN BELOW CONTAIN THE CORRECT
* INTERLEAVING FOR AN 8 INCH DISK.  IF USING 5
* INCH DISKS (SINGLE DENSITY) YOU SHOULD USE
* SOMETHING LIKE '1,3,5,7,9,2,4,6,8,10' FOR
* SSCMAP FOR A SINGLE SIDED DISK.
**************************************************

SSCMAP FCB 1,3,5,7,9,2,4,6,8,10

DSCMAP EQU SSCMAP

* STRINGS

SURES FCC 'ARE YOU SURE? '
 FCB 4
WPST FCC 'DISK IS PROTECTED!'
 FCB 4
SCRDS FCC 'SCRATCH DISK IN DRIVE '
 FCB 4
FATERS FCC 'FATAL ERROR --- '
ABORTS FCC 'FORMATTING ABORTED'
 FCB 4
BADSS FCC 'BAD SECTOR AT '
 FCB 4
CMPLTE FCC 'FORMATTING COMPLETE'
 FCB 4
SECST FCC 'TOTAL SECTORS = '
 FCB 4
DBST FCC 'DOUBLE SIDED DISK? '
 FCB 4
DDSTR FCC 'DOUBLE DENSITY DISK? '
 FCB 4
NMSTR FCC 'VOLUME NAME? '
 FCB 4
NUMSTR FCC 'VOLUME NUMBER? '
 FCB 4

***************************************************************
* WRITE TRACK ROUTINE                                         *
***************************************************************
* THIS SUBROUTINE MUST BE USER SUPPLIED.                      *
* IT SIMPLY WRITES THE DATA FOUND AT "WORK" ($0800) TO THE    *
* CURRENT TRACK ON THE DISK.  NOTE THAT THE SEEK TO TRACK     *
* OPERATION HAS ALREADY BEEN PERFORMED.  IF SINGLE DENSITY,   *
* "TKSZ" BYTES SHOULD BE WRITTEN.  IF DOUBLE, "TKSZ*2"        *
* BYTES SHOULD BE WRITTEN.  THIS ROUTINE SHOULD PERFORM       *
* ANY NECESSARY DENSITY SELECTION BEFORE WRITING.  DOUBLE     *
* DENSITY IS INDICATED BY THE BYTE "DNSITY" BEING NON-ZERO.   *
* THERE ARE NO ENTRY PARAMETERS AND ALL REGISTERS MAY BE      *
* DESTROYED ON EXIT.  THE CODE FOR THIS ROUTINE MUST NOT      *
* EXTEND PAST $0800 SINCE THE TRACK DATA IS STORED THERE.     *
***************************************************************

*********************************************
* WESTERN DIGITAL PARAMETERS
* ******* ******* *********
* REGISTERS:
COMREG EQU $8018 COMMAND REGISTER
TRKREG EQU $8019 TRACK REGISTER
SECREG EQU $801A SECTOR REGISTER
DATREG EQU $801B DATA REGISTER
* COMMANDS:
WTCMD EQU $F4 WRITE TRACK COMMAND
*********************************************

*********************************************
* CONTROLLER DEPENDENT PARAMETERS
* ********** ********* **********
DRVREG EQU $8014 DRIVE SELECT REGISTER
*********************************************


WRTTRK LDX #WORK POINT TO DATA
 LDAA #WTCMD SETUP WRITE TRACK COMMAND
 STAA COMREG ISSUE COMMAND
 JSR DELAY
WRTTR2 LDAA COMREG CHECK WD STATUS
 BITA #$02 IS WD READY FOR DATA ?
 BNE WRTTR4 SKIP IF READY
 BITA #$01 IS WD BUSY ?
 BNE WRTTR2 LOOP IF BUSY
 BRA WRTTR8 EXIT IF NOT
WRTTR4 LDAA 0,X GET A DATA BYTE
 STAA DATREG SEND TO DISK
 INX BUMP POINTER
 CPX #SWKEND OUT OF DATA ?
 BNE WRTTR2 REPEAT IF NOT
WRTTR6 BSR WAIT WAIT TIL WD IS DONE
WRTTR8 RTS RETURN

WAIT LDAA COMREG CHECK WD STATUS
 BITA #$01 IS IT BUSY?
 BNE WAIT LOOP IF SO
 RTS

DELAY JSR DELAY2
DELAY2 JSR DELAY4
DELAY4 RTS

**********************************************************
*
* BOOTSTRAP FLEX LOADER
*
* THE CODE FOR THE BOOTSTRAP FLEX LOADER MUST BE IN MEMORY
* AT $A100 WHEN NEWDISK IS RUN.  THERE ARE TWO WAYS IT CAN
* BE PLACED THERE. ONE IS TO ASSEMBLE THE LOADER AS A
* SEPERATE FILE AND APPEND IT ONTO THE END OF THE NEWDISK
* FILE.  THE SECOND IS TO SIMPLY PUT THE SOURCE FOR THE
* LOADER IN-LINE HERE WITH AN ORG TO $A100.  THE FIRST FEW
* LINES OF CODE FOR THE LATTER METHOD ARE GIVEN HERE TO
* GIVE THE USER AN IDEA OF HOW TO SETUP THE LOADER SOURCE.
*
* IT IS NOT NECESSARY TO HAVE THE LOADER AT $A100 IN ORDER
* FOR THE NEWDISK TO RUN.  IT SIMPLY MEANS THAT WHATEVER
* HAPPENS TO BE IN MEMORY AT $A100 WHEN NEWDISK IS RUN
* WOULD BE WRITTEN OUT AS A BOOT.  AS LONG AS THE CREATED
* DISK WAS FOR USE AS A DATA DISK ONLY AND WOULD NOT BE
* BOOTED FROM, THERE WOULD BE NO PROBLEM
*
**********************************************************

* 6800 BOOTSTRAP FLEX LOADER

* EQUATES

STACK EQU $A07F
SCTBUF EQU $A300 DATA SECTOR BUFFER

* START OF UTILITY

 ORG $A100
BOOT LDS #STACK SETUP STACK
 BRA LOAD0

TRK FCB 0 FILE START TRACK
SCT FCB 0 FILE START SECTOR
DNS FCB 0 DENSITY FLAG
TADR FDB $A100 TRANSFER ADDRESS
LADR FDB 0 LOAD ADDRESS
SBFPTR FDB 0 SECTOR BUFFER POINTER

LOAD0 LDAA TRK SETUP STARTING TRK & SCT
 STAA SCTBUF
 LDAA SCT
 STAA SCTBUF+1
 LDX #SCTBUF+256
 STX SBFPTR

* PERFORM ACTUAL FILE LOAD

LOAD1 BSR GETCH GET A CHARACTER
 CMPA #$02 DATA RECORD HEADER?
 BEQ LOAD2 SKIP IF SO
 CMPA #$16 XFR ADDRESS HEADER?
 BNE LOAD1 LOOP IF NEITHER
 BSR GETCH GET TRANSFER ADDRESS
 STAA TADR
 BSR GETCH
 STAA TADR+1
 BRA LOAD1 CONTINUE LOAD
LOAD2 BSR GETCH GET LOAD ADDRESS
 STAA LADR
 BSR GETCH
 STAA LADR+1
 BSR GETCH GET BYTE COUNT
 TAB PUT IN B
 BEQ LOAD1 LOOP IF COUNT=0
LOAD3 PSHB
 BSR GETCH GET A DATA CHARACTER
 PULB
 LDX LADR GET LOAD ADDRESS
 STAA 0,X PUT CHARACTER
 INX
 STX LADR
 DECB END OF DATA IN RECORD?
 BNE LOAD3 LOOP IF NOT
 BRA LOAD1 GET ANOTHER RECORD

* GET CHARACTER ROUTINE - READS A SECTOR IF NECESSARY

GETCH LDX SBFPTR CHECK SECTOR BUFFER POINTER
 CPX #SCTBUF+256 OUT OF DATA?
 BEQ GETCH2 GO READ SECTOR IF SO
GETCH1 LDAA 0,X ELSE, GET A CHARACTER
 INX
 STX SBFPTR UPDATE POINTER
 RTS
GETCH2 LDX #SCTBUF POINT TO BUFFER
 LDAA 0,X GET FORWARD LINK (TRACK)
 BEQ GO IF ZERO, FILE IS LOADED
 LDAB 1,X ELSE, GET SECTOR
 BSR READ READ NEXT SECTOR
 BNE BOOT START OVER IF ERROR
 LDX #SCTBUF+4 POINT PAST LINK
 BRA GETCH1 GO GET A CHARACTER

* FILE IS LOADED, JUMP TO IT

GO LDX TADR GET TRANSFER ADDRESS
 JMP  0,X JUMP THERE

* WESTERN DIGITAL EQUATES FOR READ

DRQ EQU 2 DRQ BIT MASK
BUSY EQU 1 BUSY MASK
RDMSK EQU $1C READ ERROR MASK
RDCMND EQU $8C READ COMMAND
SKCMND EQU $1B SEEK COMMAND

* READ ONE SECTOR

READ BSR XSEEK SEEK TO TRACK
 LDAA #RDCMND SETUP READ SECTOR COMMAND
 STAA COMREG ISSUE READ COMMAND
 BSR DEL28 DELAY
 CLRB GET SECTOR LENGTH (=256)
 LDX #SCTBUF POINT TO SECTOR BUFFER
READ3 LDAA COMREG GET WD STATUS
 BITA #DRQ CHECK FOR DATA
 BNE READ5 BRANCH IF DATA PRESENT
 BITA #BUSY CHECK IF BUSY
 BNE READ3 LOOP IF SO
 TAB  SAVE ERROR CONDITION
 BRA  READ6
READ5 LDAA DATREG GET DATA BYTE
 STAA 0,X PUT IN MEMORY
 INX BUMP THE POINTER
 DECB DEC THE COUNTER
 BNE READ3 LOOP TIL DONE
 BSR XWAIT WAIT TIL WD IS FINISHED
READ6 BITB #RDMSK MASK ERRORS
 RTS RETURN

* WAIT FOR 1771 TO FINISH COMMAND

XWAIT LDAB COMREG GET WD STATUS
 BITB #BUSY CHECK IF BUSY
 BNE XWAIT LOOP TIL NOT BUSY
 RTS RETURN

* SEEK THE SPECIFIED TRACK

XSEEK STAB SECREG SET SECTOR
 CMPA TRKREG DIF THAN LAST?
 BEQ DEL28 EXIT IF NOT
 STAA DATREG SET NEW WD TRACK
 BSR DEL28 GO DELAY
 LDAA #SKCMND SETUP SEEK COMMAND
 STAA COMREG ISSUE SEEK COMMAND
 BSR DEL28 GO DELAY
 BSR XWAIT WAIT TIL DONE

* DELAY

DEL28 JSR DEL14
DEL14 JSR DEL
DEL RTS

 END NEWDISK
