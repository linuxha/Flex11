;*[ Start ]*********************************************************************
;* TEST UTILITY
;*
;* COPYRIGHT (C) 1980 BY
;* TECHNICAL SYSTEMS CONSULTANTS, INC.
;* BOX 2570; W. LAFAYETTE, IN 47906
;*
;* TESTS SINGLE SECTOR READ AND WRITE ROUTINES.
;* PROGRAM PROMPTS USER FOR FUNCTION (F?) TO WHICH THE
;* USER CAN RESPOND 'R' (READ) OR 'W' (WRITE). THEN IT
;* PROMPTS FOR SINGLE DIGIT DRIVE NUMBER (D?), TWO DIGIT
;* HEX TRACK NUMBER (T?) AND TWO DIGIT HEX SECTOR 
;* NUMBER (S?). AFTER PERFORMING THE FUNCTION, TEST
;* REPEATS THE PROMPTING FOR ANOTHER FUNCTION.
;*
;* ASSUMES THE CONSOLE I/O PACKAGE DRIVERS ARE RESIDENT.
;* BEGIN EXECUTION BY JUMPING TO $0100.
;*
;*    EQUATES
;*
INCH	EQU  $B3FB	;* 
OUTCH	EQU  $B3F9	;* 
TINIT	EQU  $B3F5	;* 
MONITR	EQU  $B3F3	;* 
STACK	EQU  $A07F	;* 
FCB	EQU  $A840	;* 
BUFFER	EQU  $1000	;* 
READ	EQU  $BE80	;* 
WRITE	EQU  $BE83	;* 
DRIVE	EQU  $BE8C	;* 


;* TEMPORARY STORAGE


	ORG  $0020	;* 
COMMND	RMB  1  	;* 
TRACK	RMB  1  	;* 
SECTOR	RMB  1  	;* 
BYTE	RMB  1  	;* 


;* START OF PROGRAM


	ORG  $0100	;* 


TEST	LDS  #STACK	;* SETUP STACK XXXXXXXX
	LDX  TINIT	;* 
	JSR  0,X 	;* INITIALIZE TERMINAL
	LDX  INCH	;* SETUP INPUT
	STX  INPUT+1	;* 
	LDX  OUTCH	;* SETUP OUTPUT
	STX  OUTPUT+1	;* 


;* GET COMMAND


TEST1	LDS  #STACK	;* RESET STACK XXXXXXXX
	BSR  PCRLF	;* 
	LDAA #'F'       ;* PROMPT FOR FUNCTION (l == 2)
	BSR  PROMPT	;* 
	BSR  INPUT	;* GET RESPONSE
;* Func1
	CMPA #'R'       ;* READ COMMAND?
	BEQ  TEST2	;* 
;* Func1
	CMPA #'W'       ;* WRITE COMMAND?
	BEQ  TEST2	;* 
	LDX  MONITR	;* 
	JMP  0,X 	;* EXIT THE PROGRAM
TEST2	STAA COMMND	;* SAVE COMMAND XXXXXXXX
	LDAA #'D'       ;* PROMPT FOR DRIVE (l == 2)
	BSR  PROMPT	;* 
	JSR  INHEX	;* GET RESPONSE
;* Func1
	CMPA #4         ;* ENSURE 0 TO 3
	BHS  TEST1	;* 
	STAA FCB+3      ;* SAVE IT (l == 2)
	LDAA #'T'       ;* PROMPT FOR TRACK (l == 2)
	BSR  HPRMPT	;* GET HEX PROMPT
	STAA TRACK      ;* (l == 2)
	LDAA #'S'       ;* PROMPT FOR SECTOR (l == 2)
	BSR  HPRMPT	;* GET HEX RESPONSE
	STAA SECTOR     ;* SAVE IT (l == 2)
	BSR  PCRLF	;* DO LINE FEED


;* GOT COMMAND, NOW DO IT


	LDAA  COMMND    ;* GET COMMAND (l == 2)
;* Func1
	CMPA #'W'       ;* A WRITE COMMAND?
	BNE  DOREAD	;* IF NOT, ITS A READ
	BSR  SELECT	;* SELECT DRIVE
	LDX  #BUFFER	;* POINT TO BUFFER
	LDAA TRACK      ;* POINT TO TRACK (l == 2)
	LDAB SECTOR     ;* POINT TO SECTOR (l == 2)
	JSR  WRITE	;* WRITE THE DATA
	BNE  ERROR	;* 
	BSR  PCRLF	;* 
	LDAA #'O'       ;* PRINT OK (l == 2)
	BSR  OUTPUT	;* 
	LDAA #'K'       ;* (l == 2)
	BSR  OUTPUT	;* 
XX	BRA  TEST1	;* DO AGAIN XXXXXXXX


;* PROMPT ROUTINES


PROMPT	BSR  PCRLF	;* DO LINE FEED XXXXXXXX
	BSR  OUTPUT	;* OUTPUT PROMPT LETTER
	BRA  QUEST	;* PRINT QUESTION MARK
HPRMPT	BSR  PROMPT	;* DO PROMPT XXXXXXXX
	BRA  INBYTE	;* GET HEX BYTE


;* CARRIAGE RETURN LINE FEED ROUTINE


PCRLF	PSHA            ;* SAVE A XXXXXXXX
	LDAA #$0D       ;* RETURN (l == 2)
	BSR  OUTPUT	;* 
	LDAA #$0A       ;* LINE FEED (l == 2)
	BSR  OUTPUT	;* 
	PULA		;* RESTORE A (l == 2)
RET	RTS		;* (LABEL/NM only?)


;* I/O ROUTINES


INPUT	JMP  INPUT	;* (WILL BE OVERLAYED) XXXXXXXX
QUEST	LDAA #'?'  	;*
OUTPUT	JMP  OUTPUT	;* (WILL BE OVERLAID) XXXXXXXX


;* DRIVE SELECT ROUTINE


SELECT	LDX  #FCB	;*
	JSR  DRIVE	;* 
	BEQ  RET 	;* RETURN IF NO ERROR


;* DRIVER ERROR


ERROR	BSR  PCRLF	;*
	LDAA #'E'       ;* (l == 2)
	BSR  OUTPUT	;* 
	LDAA #'='       ;* (l == 2)
	BSR  OUTPUT	;* 
	TBA		;* GET ERROR CODE (l == 2)
	BSR  OUTHEX	;* 
	BRA  XX 	;* START OVER


;* DO SINGLE SECTOR READ


DOREAD	BSR  SELECT	;* SELECT DRIVE XXXXXXXX
	LDX  #BUFFER	;* POINT TO BUFFER
	LDAA TRACK      ;* POINT TO TRACK (l == 2)
	LDAB SECTOR     ;* POINT TO SECTOR (l == 2)
	JSR  READ	;* READ THE DATA
	BNE  ERROR	;* 


;* DUMP DATA TO CONSOLE


DUMP	LDX  #BUFFER	;*
	LDAA #16        ;* NO OF LINES (l == 2)
DUMP1	PSHA            ;* SAVE NO OF LINES XXXXXXXX
	BSR  PCRLF	;* 
	LDAB #16        ;* NO OF BYTES (l == 2)
DUMP2	LDAA 0,X	;* GET A BYTE XXXXXXXX
	INX		;* 
	BSR  OUTHEX	;* OUTPUT IT
	DECB		;* DONE WITH LINE? (l == 2)
	BNE  DUMP2	;* 
	PULA		;* GET NO LINES (l == 2)
	DECA		;* DONE WITH DUMP? (l == 2)
	BNE  DUMP1	;* LOOP IF NOT
	BRA  XX 	;* GET NEXT COMMAND


;* INPUT HEX BYTE ROUTINE


INBYTE	BSR  INHEX	;*
	ASLA		;* 
	ASLA		;* 
	ASLA		;* 
	ASLA		;* 
	STAA BYTE       ;* (l == 2)
	BSR  INHEX	;* 
	ADDA BYTE       ;* (l == 2)
RETN	RTS		;* (LABEL/NM only?)
INHEX	BSR  INPUT	;*
	SUBA #$47       ;* (l == 2)
	BPL  INERR	;* 
	ADDA #6		;* (l == 2)
	BPL  INH2	;* 
	ADDA #7		;* (l == 2)
	BPL  INERR	;* 
INH2	ADDA #10  	;*
	BPL  RETN	;* 
INERR	BSR  QUEST	;* PRINT A QUESTION MARK XXXXXXXX
	BRA  XX 	;* GO START OVER


;* OUTPUT HEX BYTE (FOLLOWED BY SPACE)


OUTHEX	PSHA		;* (LABEL/NM only?)
	LSRA		;* 
	LSRA		;* 
	LSRA		;* 
	LSRA		;* 
	BSR  OUTHR	;* 
	PULA		;* 
	BSR  OUTHR	;* 
	LDAA #$20       ;* (l == 2)
	BRA  OUTPUT	;* 
OUTHR	ANDA #$0F	;*
	ADDA #$90       ;* (l == 2)
	DAA		;* 
	ADCA #$40       ;* (l == 2)
	DAA		;* 
	BRA  OUTPUT	;* 


	END		;* 
;*[ Fini ]**********************************************************************
;/* Local Variables: */
;/* mode:asm         */
;/* End:             */
