;*[ Start ]*********************************************************************


;***************************************************************
;* WRITE TRACK ROUTINE                                         *
;***************************************************************
;* THIS SUBROUTINE MUST BE USER SUPPLIED.                      *
;* IT SIMPLY WRITES THE DATA FOUND AT "WORK" ($0800) TO THE    *
;* CURRENT TRACK ON THE DISK.  NOTE THAT THE SEEK TO TRACK     *
;* OPERATION HAS ALREADY BEEN PERFORMED.  IF SINGLE DENSITY,   *
;* "TKSZ" BYTES SHOULD BE WRITTEN.  IF DOUBLE, "TKSZ*2"        *
;* BYTES SHOULD BE WRITTEN.  THIS ROUTINE SHOULD PERFORM       *
;* ANY NECESSARY DENSITY SELECTION BEFORE WRITING.  DOUBLE     *
;* DENSITY IS INDICATED BY THE BYTE "DNSITY" BEING NON-ZERO.   *
;* THERE ARE NO ENTRY PARAMETERS AND ALL REGISTERS MAY BE      *
;* DESTROYED ON EXIT.  THE CODE FOR THIS ROUTINE MUST NOT      *
;* EXTEND PAST $0800 SINCE THE TRACK DATA IS STORED THERE.     *
;***************************************************************


;*********************************************
;* WESTERN DIGITAL PARAMETERS
;* ******* ******* *********
;* REGISTERS:
COMREG	EQU  $8018	;* COMMAND REGISTER
TRKREG	EQU  $8019	;* TRACK REGISTER
SECREG	EQU  $801A	;* SECTOR REGISTER
DATREG	EQU  $801B	;* DATA REGISTER
;* COMMANDS:
WTCMD	EQU  $F4  	;* WRITE TRACK COMMAND
;*********************************************

;* SIZE OF SINGLE DENSITY WORK BUFFER FOR ONE TRACK
TKSZ    EQU  3050       ;* (USE 3050 FOR 5 INCH)
;* WORK SPACE WHERE ONE TRACK OF DATA IS SETUP
WORK    EQU  $0800      ;* WORK SPACE
SWKEND  EQU  TKSZ+WORK  ;* SINGLE DENSITY
DWKEND  EQU  TKSZ*2+WORK        ;* DOUBLE DENSITY


;*********************************************
;* CONTROLLER DEPENDENT PARAMETERS
;* ********** ********* **********
DRVREG	EQU  $8014	;* DRIVE SELECT REGISTER
;*********************************************


WRTTRK	LDX  #WORK	;* POINT TO DATA XXXXXXXX
	LDAA #WTCMD     ;* SETUP WRITE TRACK COMMAND (l == 2)
	STAA COMREG     ;* ISSUE COMMAND (l == 2)
	JSR  DELAY	;* 
WRTTR2	LDAA COMREG	;* CHECK WD STATUS XXXXXXXX
	BITA #$02       ;* IS WD READY FOR DATA ? (l == 2)
	BNE  WRTTR4	;* SKIP IF READY
	BITA #$01       ;* IS WD BUSY ? (l == 2)
	BNE  WRTTR2	;* LOOP IF BUSY
	BRA  WRTTR8	;* EXIT IF NOT
WRTTR4	LDAA 0,X	;* GET A DATA BYTE XXXXXXXX
	STAA DATREG     ;* SEND TO DISK (l == 2)
	INX		;* BUMP POINTER (l == 2)
	CPX  #SWKEND	;* OUT OF DATA ?
	BNE  WRTTR2	;* REPEAT IF NOT
WRTTR6	BSR  WAIT	;* WAIT TIL WD IS DONE XXXXXXXX
WRTTR8	RTS             ;* RETURN


WAIT	LDAA COMREG	;* CHECK WD STATUS XXXXXXXX
	BITA #$01       ;* IS IT BUSY? (l == 2)
	BNE  WAIT	;* LOOP IF SO
	RTS		;* 


DELAY	JSR  DELAY2	;*
DELAY2	JSR  DELAY4	;*
DELAY4	RTS		;* (LABEL/NM only?)


;**********************************************************
;*
;* BOOTSTRAP FLEX LOADER
;*
;* THE CODE FOR THE BOOTSTRAP FLEX LOADER MUST BE IN MEMORY
;* AT $A100 WHEN NEWDISK IS RUN.  THERE ARE TWO WAYS IT CAN
;* BE PLACED THERE. ONE IS TO ASSEMBLE THE LOADER AS A
;* SEPERATE FILE AND APPEND IT ONTO THE END OF THE NEWDISK
;* FILE.  THE SECOND IS TO SIMPLY PUT THE SOURCE FOR THE
;* LOADER IN-LINE HERE WITH AN ORG TO $A100.  THE FIRST FEW
;* LINES OF CODE FOR THE LATTER METHOD ARE GIVEN HERE TO
;* GIVE THE USER AN IDEA OF HOW TO SETUP THE LOADER SOURCE.
;*
;* IT IS NOT NECESSARY TO HAVE THE LOADER AT $A100 IN ORDER
;* FOR THE NEWDISK TO RUN.  IT SIMPLY MEANS THAT WHATEVER
;* HAPPENS TO BE IN MEMORY AT $A100 WHEN NEWDISK IS RUN
;* WOULD BE WRITTEN OUT AS A BOOT.  AS LONG AS THE CREATED
;* DISK WAS FOR USE AS A DATA DISK ONLY AND WOULD NOT BE
;* BOOTED FROM, THERE WOULD BE NO PROBLEM
;*
;**********************************************************


;* 6800 BOOTSTRAP FLEX LOADER


;* EQUATES


STACK	EQU  $A07F	;* 
SCTBUF	EQU  $A300	;* DATA SECTOR BUFFER


;* START OF UTILITY


	ORG  $A100	;* 
BOOT	LDS  #STACK	;* SETUP STACK XXXXXXXX
	BRA  LOAD0	;* 


TRK	FCB  0  	;* FILE START TRACK
SCT	FCB  0  	;* FILE START SECTOR
DNS	FCB  0  	;* DENSITY FLAG
TADR	FDB  $A100	;* TRANSFER ADDRESS
LADR	FDB  0  	;* LOAD ADDRESS
SBFPTR	FDB  0  	;* SECTOR BUFFER POINTER


LOAD0	LDAA TRK	;* SETUP STARTING TRK & SCT XXXXXXXX
	STAA SCTBUF     ;* (l == 2)
	LDAA SCT        ;* (l == 2)
	STAA SCTBUF+1   ;* (l == 2)
	LDX  #SCTBUF+256	;* 
	STX  SBFPTR	;* 


;* PERFORM ACTUAL FILE LOAD


LOAD1	BSR  GETCH	;* GET A CHARACTER XXXXXXXX
;* Func1
	CMPA #$02       ;* DATA RECORD HEADER?	;*
	BEQ  LOAD2	;* SKIP IF SO
;* Func1
	CMPA #$16       ;* XFR ADDRESS HEADER?	;*
	BNE  LOAD1	;* LOOP IF NEITHER
	BSR  GETCH	;* GET TRANSFER ADDRESS
	STAA TADR       ;* (l == 2)
	BSR  GETCH	;* 
	STAA TADR+1     ;* (l == 2)
	BRA  LOAD1	;* CONTINUE LOAD
LOAD2	BSR  GETCH	;* GET LOAD ADDRESS XXXXXXXX
	STAA LADR       ;* (l == 2)
	BSR  GETCH	;* 
	STAA LADR+1     ;* (l == 2)
	BSR  GETCH	;* GET BYTE COUNT
	TAB             ;* PUT IN B (l == 2)
	BEQ  LOAD1	;* LOOP IF COUNT=0
LOAD3	PSHB		;* (LABEL/NM only?)
	BSR  GETCH	;* GET A DATA CHARACTER
	PULB		;* 
	LDX  LADR	;* GET LOAD ADDRESS
	STAA 0,X        ;* PUT CHARACTER (l == 2)
	INX		;* 
	STX  LADR	;* 
	DECB		;* END OF DATA IN RECORD? (l == 2)
	BNE  LOAD3	;* LOOP IF NOT
	BRA  LOAD1	;* GET ANOTHER RECORD


;* GET CHARACTER ROUTINE - READS A SECTOR IF NECESSARY


GETCH	LDX  SBFPTR	;* CHECK SECTOR BUFFER POINTER XXXXXXXX
	CPX  #SCTBUF+256	;* OUT OF DATA?
	BEQ  GETCH2	;* GO READ SECTOR IF SO
GETCH1	LDAA 0,X	;* ELSE, GET A CHARACTER XXXXXXXX
	INX		;* 
	STX  SBFPTR	;* UPDATE POINTER
	RTS		;* 
GETCH2	LDX  #SCTBUF	;* POINT TO BUFFER XXXXXXXX
	LDAA 0,X        ;* GET FORWARD LINK (TRACK) (l == 2)
	BEQ  GO 	;* IF ZERO, FILE IS LOADED
	LDAB 1,X        ;* ELSE, GET SECTOR (l == 2)
	BSR  READ	;* READ NEXT SECTOR
	BNE  BOOT	;* START OVER IF ERROR
	LDX  #SCTBUF+4	;* POINT PAST LINK
	BRA  GETCH1	;* GO GET A CHARACTER


;* FILE IS LOADED, JUMP TO IT


GO	LDX  TADR	;* GET TRANSFER ADDRESS XXXXXXXX
	JMP  0,X 	;* JUMP THERE


;* WESTERN DIGITAL EQUATES FOR READ


DRQ	EQU  2  	;* DRQ BIT MASK
BUSY	EQU  1  	;* BUSY MASK
RDMSK	EQU  $1C  	;* READ ERROR MASK
RDCMND	EQU  $8C  	;* READ COMMAND
SKCMND	EQU  $1B  	;* SEEK COMMAND


;* READ ONE SECTOR


READ	BSR  XSEEK	;* SEEK TO TRACK XXXXXXXX
	LDAA #RDCMND    ;* SETUP READ SECTOR COMMAND (l == 2)
	STAA COMREG     ;* ISSUE READ COMMAND (l == 2)
	BSR  DEL28	;* DELAY
	CLRB		;* GET SECTOR LENGTH (=256) (l == 2)
	LDX  #SCTBUF	;* POINT TO SECTOR BUFFER
READ3	LDAA COMREG	;* GET WD STATUS XXXXXXXX
	BITA #DRQ       ;* CHECK FOR DATA (l == 2)
	BNE  READ5	;* BRANCH IF DATA PRESENT
	BITA #BUSY      ;* CHECK IF BUSY (l == 2)
	BNE  READ3	;* LOOP IF SO
	TAB		;* SAVE ERROR CONDITION (l == 2)
	BRA  READ6	;* 
READ5	LDAA DATREG	;* GET DATA BYTE XXXXXXXX
	STAA 0,X        ;* PUT IN MEMORY (l == 2)
	INX		;* BUMP THE POINTER (l == 2)
	DECB		;* DEC THE COUNTER (l == 2)
	BNE  READ3	;* LOOP TIL DONE
	BSR  XWAIT	;* WAIT TIL WD IS FINISHED
READ6	BITB #RDMSK	;* MASK ERRORS XXXXXXXX
	RTS		;* RETURN (l == 2)


;* WAIT FOR 1771 TO FINISH COMMAND


XWAIT	LDAB COMREG	;* GET WD STATUS XXXXXXXX
	BITB #BUSY      ;* CHECK IF BUSY (l == 2)
	BNE  XWAIT	;* LOOP TIL NOT BUSY
	RTS		;* RETURN (l == 2)


;* SEEK THE SPECIFIED TRACK


XSEEK	STAB SECREG	;* SET SECTOR XXXXXXXX
;* Func1
	CMPA TRKREG     ;* DIF THAN LAST?
	BEQ  DEL28	;* EXIT IF NOT
	STAA DATREG     ;* SET NEW WD TRACK (l == 2)
	BSR  DEL28	;* GO DELAY
	LDAA #SKCMND    ;* SETUP SEEK COMMAND (l == 2)
	STAA COMREG     ;* ISSUE SEEK COMMAND (l == 2)
	BSR  DEL28	;* GO DELAY
	BSR  XWAIT	;* WAIT TIL DONE


;* DELAY


DEL28	JSR  DEL14	;*
DEL14	JSR  DEL  	;*
DEL	RTS		;* (LABEL/NM only?)


	END		;* NEWDISK (l == 2)
;*[ Fini ]**********************************************************************
;/* Local Variables: */
;/* mode:asm         */
;/* End:             */
